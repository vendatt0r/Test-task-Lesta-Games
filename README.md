# Test-task-Lesta-Games

## Вопрос №1
На языке Python написать алгоритм (функцию) определения четности целого числа, который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути. Объяснить плюсы и минусы обеих реализаций. 

### Пример: 
```
def isEven(value):
      return value % 2 == 0
```

### Плюсы:
- Код читается легче, потому что такая реализация более привычна.
- Совместима с целыми числами, независимо от знака и размера.

### Минусы:
- Операция взятия остатка может быть менее эффективной, чем побитовое И, на некоторых процессорах.
- Потенциально чуть медленнее на больших данных, поскольку взятие остатка — арифметическая операция.
    
### Алгоритм с использованием побитового И:
```
def isEven(value):
    return (value & 1) == 0
```
### Плюсы:
- Операция побитового И обычно выполняется быстрее, чем взятие остатка, поскольку работает на уровне битов.
- Может быть предпочтительным в задачах, требующих высокой оптимизации и работы с низкоуровневыми операциями.

### Минусы:
- Менее читаемая для большинства программистов, так как проверка четности через побитовое И не так очевидна.
- Ограничена целыми числами; для вещественных чисел не подходит.

## Вопрос №2
На языке Python написать минимум по 2 класса реализовывающих циклический буфер FIFO. Объяснить плюсы и минусы каждой реализации.

## Вопрос №3
На языке Python предложить алгоритм, который быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел. Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным). Объяснить, почему вы считаете, что функция соответствует заданным критериям.

Я считаю, что лучше всего будет использовать Timsort, поскольку сочетает преимущества сортировки слиянием и сортировки вставками. В Python есть готовый метод sort(), использующий Timsort.
```
def top_sort(arr):
    arr.sort()
    return arr
```
